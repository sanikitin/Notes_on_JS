<h1><b>Javascript</b></h1>

<hr />
<hr />

<h2>Содержание:</h2>
<ol>
  <li><a href="https://github.com/sanikitin/Notes_on_JS#%D0%BE%D0%B1%D1%89%D0%B0%D1%8F-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F">Общая информация</a></li>
  <li><a href="https://github.com/sanikitin/Notes_on_JS#%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D1%8B">Основы</a></li>
  <li><a href="https://github.com/sanikitin/Notes_on_JS#%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5">Переменные</a></li>
  <li><a href="https://github.com/sanikitin/Notes_on_JS#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D1%8B">Константы</a></li>
  <li><a href="https://github.com/sanikitin/Notes_on_JS#%D1%82%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">Типы данных</a></li>
  <li><a href="https://github.com/sanikitin/Notes_on_JS#%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2">Преобразование типов</a></li>
  <li><a href="https://github.com/sanikitin/Notes_on_JS#%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B">Базовые операторы</a></li>
  <li><a href="https://github.com/sanikitin/Notes_on_JS#%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%B2%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">Условные ветвления</a></li>
  <li><a href="https://github.com/sanikitin/Notes_on_JS#%D1%86%D0%B8%D0%BA%D0%BB%D1%8B-while-%D0%B8-for">Циклы while и for</a></li>
  <li><a href="https://github.com/sanikitin/Notes_on_JS#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D1%8F-switch">Конструкция "switch"</a></li>
  <li><a href="https://github.com/sanikitin/Notes_on_JS#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8">Функции</a></li>
</ol>

<hr />
<hr />

<h3><b>Общая информация</b></h3>

Javascript - это язык программирования с помощью которого можно писать скрипты (прогарммы), которые можно встраивать в HTML код. Для них не нужна компиляция для запуска.

Запуск Javascripta на других устрйоствах реализуется с помощью предустановленного движка или по другому виртуальной машины Javascript. 
Например:
В Chrome и Opera используется движок V8, а в Firefox движок SpiderMonkey.

В разных движках возможны разные функциональности, поэтому нужно понимать, где какой движок используется, чтобы знать запустится или нет определенный функционал.
Посмотреть можно тут:
- http://caniuse.com – таблицы с информацией о поддержке по каждой возможности языка.
- https://kangax.github.io/compat-table – таблица с возможностями языка и движками, которые их поддерживают и не поддерживают.

Принцип работы движка:
1. Движок, например в браузере, читает текст скрипта;
2. Преобразует текст в машинный код;
3. Запускает полученный машинный код.

На каждом этапе происходит оптимизация машинного кода. Благодаря чему можно добиться значительного быстродействия.

Javascript не строго типизированный язык. Для строгой типизации нужен другой язык, который преобразуется автоматически в Javascript. TypeScript концентрируется на добавлении «строгой типизации» для упрощения разработки и поддержки больших и сложных систем. Разработан Microsoft.

Если, что то непонятное, то самая полная информация по Javascript находится в спецификации: https://www.ecma-international.org/publications/standards/Ecma-262.htm

<hr />
<hr />

Основная работа в браузере - это исправление багов. Поэтому, важно понимать, как работать с консолью разработчика в браузере.
Обычно она открывается клавишей F12.

<hr />
<hr />

<h3><b>Основы</b></h3>

<hr />
<hr />

<h4><b>Подключение скрипта</b></h4>

Программы на JavaScript могут быть вставлены в любое место HTML-документа с помощью тега ```<script>```. Например:
```javascript
<!DOCTYPE HTML>
<html>
<body>
  <p>Перед скриптом...</p>
  <script>
    alert( 'Привет, мир!' );
  </script>
  <p>...После скрипта.</p>
</body>
</html>
```
Тег ```<script>``` имеет несколько атрибутов, которые редко используются, но всё ещё могут встретиться в старом коде:
- Атрибут type: ```<script type=…>```
Старый стандарт HTML, HTML4, требовал наличия этого атрибута в теге ```<script>```. Обычно он имел значение ```type="text/javascript"```. На текущий момент этого больше не требуется. 
- Атрибут language: ```<script language=…>```
Этот атрибут должен был задавать язык, на котором написан скрипт. Но так как JavaScript является языком по умолчанию, в этом атрибуте уже нет необходимости.

В основном сейчас файл скрипта подключают к HTML с помощью атрибута src. Синтаксис: ```<script src="/path/to/script.js"></script>```
В пути можно указать:
- абсолютный путь до скрипта от корня сайта (```src="/path/to/script.js"```);
- относительный путь от текущей страницы (```src="script.js"```);
- URL-адрес (```https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js```).
Если скриптов несколько, то просто используется несколько тегов.

ВАЖНО!: Если атрибут ```src``` установлен, содержимое тега ```<script>``` будет игнорироваться.

Польза от отдельных файлов ещё и в том, что браузер загрузит скрипт отдельно и сможет хранить его в кеше. Другие страницы, которые подключают тот же скрипт, смогут брать его из кеша вместо повторной загрузки из сети. И таким образом файл будет загружаться с сервера только один раз. Это сокращает расход трафика и ускоряет загрузку страниц.

<hr />
<hr />

<h4><b>Структура кода</b></h4>

Инструкции – это синтаксические конструкции и команды, которые выполняют действия.
Пример: ```alert('Привет, мир!');```
Желательно писать команду с новой строки, чтобы было проще читать.

Точку с запятой в конце можно ставить, а можно не ставить. Пример:
```javascript
alert('Привет')
alert('Мир')
```
Это выполнится, как две команды.
НО! во избежании ошибок, которые потом не найдешь лучше всегда использовать точку с запятой.

Есть возможность комментировать код. Комментариев два вида: 
- Однострочный;
```javascript
alert('Мир'); // Этот комментарий следует за инструкцией
```
- Многострочный;
```javascript
/* 
Это - многострочный комментарий.
*/
alert('Привет');
```
Вложение комментариев друг в друга не поддерживается.

<hr />
<hr />

Чтобы отключить поддержку обратной совместимости в коде и работать с скриптом в современном режиме используется команда ```"use strict"``` или ```'use strict'```.

ВАЖНО!: ```"use strict"``` должен находится в первой исполняемой строке скрипта, иначе строгий режим может не включиться. И отменить этот режим невозможно. Его можно только включить, но не выключить.

```'use strict'``` по умолчанию в консоли браузера выключен. Иногда, когда ```'use strict'``` имеет значение можно получить неправильные результаты.

Современный JavaScript поддерживает «классы» и «модули», которые автоматически включают строгий режим. Поэтому в них нет нужды добавлять директиву "use strict".

<hr />
<hr />

<h4><b>Взаимодействия: функции интерфейса браузера.</b></h4>

Все эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать с остальной частью страницы до тех пор, пока окно не будет закрыто.

На все указанные методы распространяются два ограничения:
- Расположение окон определяется браузером. Обычно окна находятся в центре.
- Визуальное отображение окон зависит от браузера, и мы не можем изменить их вид.

1. ```alert``` - показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК».
```javascript
alert("Hello");
```

2. ```prompt```
```javascript
result = prompt(title, [default]);
```
Этот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.
Функция ```prompt``` принимает два аргумента:
- ```title``` - Текст для отображения в окне.
- ```default``` - Необязательный второй параметр, который устанавливает начальное значение в поле для текста в окне.
Особенность: Квадратные скобки вокруг ```default``` в описанном выше синтаксисе означают, что параметр факультативный, необязательный.

Как работает: Пользователь может напечатать что-либо в поле ввода и нажать OK. Введённый текст будет присвоен переменной ```result```. Пользователь также может отменить ввод нажатием на кнопку «Отмена» или нажав на клавишу Esc. В этом случае значением ```result``` станет ```null```.

Через ```promt``` можно присваивать введенное значение переменной:
```javascript
let age = prompt('Сколько тебе лет?', 100);
alert(`Тебе ${age} лет!`); // Тебе 100 лет!
```
ВАЖНО!: Второй параметр является необязательным, но если не указать его, то Internet Explorer вставит строку ```"undefined"``` в поле для ввода.

3. ```confirm``` - отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена. Результат – ```true```, если нажата кнопка OK. В других случаях – ```false```. Пример:
```javascript
result = confirm(question);
```

<hr />
<hr />

<h3><b>Переменные</b></h3>

В Javascript есть переменные, как и в остальных языках программирования.
Объявляется с помощью команды let. 
Примеры:
```javascript
let message;

message = 'Hello'; // сохранить строку
alert(message); // показывает содержимое переменной
```
Или
```javascript
let message = 'Hello!'; // определяем переменную и присваиваем ей значение
```
Можно объявлять несколько переменных в одной строке. Но это уменьшает читаемость кода.
```javascript
let user = 'John', age = 25, message = 'Hello';
```
Ранее, использовалось также ```var```, но сейчас оно устарело. Оно имеет отличия в поведении и сейчас не используется.

ВАЖНО!: Повторное объявление вызывает ошибку "SyntaxError: 'message' has already been declared". Переменная может быть объявлена только один раз. Поэтому следует объявлять переменную только один раз и затем использовать её уже без ```let```.

В JavaScript есть два ограничения, касающиеся имён переменных:
- Имя переменной должно содержать только буквы, цифры или символы $ и _.
- Первый символ не должен быть цифрой.

Если имя содержит несколько слов, обычно используется верблюжья нотация, это хорошая практика: myVeryLongName.

ВАЖНО!: Регистр имеет значение. Переменные с именами apple и AppLE – это две разные переменные.

Также, как и в остальных языках нельзя использовать зарезервированные имена: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0

<hr />
<hr />

<h3><b>Константы</b></h3>

Чтобы объявить константу (неизменяемую переменную) используется ```const```.
```javascript
const myBirthday = '21.11.1991';
```

Особенность: Широко распространена практика использования констант в качестве псевдонимов, которые известны до начала исполнения скрипта. Названия таких констант пишутся с использованием заглавных букв и подчёркивания.
```javascript
const COLOR_RED = "#F00";
```
Другими словами, константы с именами, записанными заглавными буквами, используются только как псевдонимы для «жёстко закодированных» значений.


Название переменной должно иметь ясный и понятный смысл, говорить о том, какие данные в ней хранятся. Именование переменных – это один из самых важных и сложных навыков в программировании.
Несколько хороших правил:
- Используйте легко читаемые имена, такие как ```userName``` или ```shoppingCart```.
- Избегайте использования аббревиатур или коротких имён, таких как a, b, c, за исключением тех случаев, когда вы точно знаете, что так нужно.
- Делайте имена максимально описательными и лаконичными. Примеры плохих имён: ```data``` и ```value```. Такие имена ничего не говорят. Их можно использовать только в том случае, если из контекста кода очевидно, какие данные хранит переменная.
- Договоритесь с вашей командой об используемых терминах. Если посетитель сайта называется ```«user»```, тогда мы должны называть связанные с ним переменные ```currentUser``` или ```newUser```, а не, к примеру, ```currentVisitor``` или ```newManInTown```.

<hr />
<hr />

<h3><b>Типы данных</b></h3>

Есть восемь основных типов данных в JavaScript. Переменная в JavaScript может содержать любые данные. В один момент там может быть строка, а в другой – число:
```javascript
let message = "hello";
message = 123456;
```
Языки программирования, в которых такое возможно, называются «динамически типизированными». Это значит, что типы данных есть, но переменные не привязаны ни к одному из них.

1. Числовой тип данных (number) представляет как целочисленные значения, так и числа с плавающей точкой. С ними можно выполнять все стандартные арифметически операции.
Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: ```Infinity```, ```-Infinity``` и ```NaN```.
а) ```Infinity``` представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа. Мы можем получить его в результате деления на ноль:
```javascript
alert( 1 / 0 ); // Infinity
```
Или задать его явно:
```javascript
alert( Infinity ); // Infinity
```
б) ```NaN``` означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:
```javascript
alert( "не число" / 2 ); // NaN
```
Такое деление является ошибкой.
Значение ```NaN``` «прилипчиво». Любая операция с ```NaN``` возвращает ```NaN```:
```javascript
alert( "не число" / 2 + 5 ); // NaN
```

Особенности: 
1. Математические операции в JavaScript «безопасны». Можно делать что угодно. Скрипт никогда не остановится с фатальной ошибкой. В худшем случае мы получим ```NaN``` как результат выполнения.
2. В JavaScript тип «number» не может содержать числа больше, чем (2 в 53 степени -1) (т. е. 9007199254740991), или меньше, чем -(2 в 53 степени -1) для отрицательных чисел. Это техническое ограничение вызвано их внутренним представлением.


2. Тип ```BigInt``` был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины. Чтобы создать значение типа ```BigInt```, необходимо добавить n в конец числового литерала:
```javascript
// символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n;
```
Особенность: ```BigInt``` имеет проблемы с поддержкой, поэтому нужно проверять поддерживает ли его браузер.

3. Строка (```string```) в JavaScript должна быть заключена в кавычки. В JavaScript существует три типа кавычек.
а) Двойные кавычки: ```"Привет"```.
б) Одинарные кавычки: ```'Привет'```.
в) Обратные кавычки: `Привет`.

Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript. Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в ${…}. Например:
```javascript
let name = "Иван";
// Вставим переменную
alert( `Привет, ${name}!` ); // Привет, Иван!
// Вставим выражение
alert( `результат: ${1 + 2}` ); // результат: 3
```
Особенность: Нет отдельного типа данных для одного символа. В C и Java, для хранения одного символа существует отдельный тип char. В JavaScript есть только тип string. Строка может содержать ноль символов (быть пустой), один символ или множество.

4. Булевый тип (```boolean```) может принимать только два значения: ```true``` (истина) и ```false``` (ложь). Пример: 
```javascript
let nameFieldChecked = true; // да, поле отмечено
let ageFieldChecked = false; // нет, поле не отмечено
```
Булевые значения также могут быть результатом сравнений:
```javascript
let isGreater = 4 > 1;
alert( isGreater ); // true (результатом сравнения будет "да")
```

5. Специальное значение ```null```. В JavaScript ```null``` не является «ссылкой на несуществующий объект» или «нулевым указателем». Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно». Пример:
```javascript
let age = null;
```

6. Специальное значение ```undefined```. Оно означает, что «значение не было присвоено». Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined:
```javascript
let age;
alert(age); // выведет "undefined"
```
Технически мы можем присвоить значение ```undefined```. Но так делать не рекомендуется. Обычно ```null``` используется для присвоения переменной «пустого» или «неизвестного» значения, а ```undefined``` – для проверок, была ли переменная назначена.

7. Тип ```object``` (объект). В объектах же хранят коллекции данных или более сложные структуры.

8. Тип ```symbol``` (символ) используется для создания уникальных идентификаторов в объектах.

Оператор ```typeof``` возвращает тип аргумента. Это полезно, когда мы хотим обрабатывать значения различных типов по-разному или просто хотим сделать проверку. У него есть две синтаксические формы:
- Синтаксис оператора: ```typeof x```.
- Синтаксис функции: ```typeof (x)```.
Результат одинаковый. Вызов ```typeof x``` возвращает строку с именем типа:
```javascript
typeof undefined // "undefined"
typeof 0 // "number"
typeof 10n // "bigint"
typeof true // "boolean"
typeof "foo" // "string"
typeof Symbol("id") // "symbol"
typeof Math // "object"  (1)
typeof null // "object"  (2)
typeof alert // "function"  (3)
```
ВАЖНО!:
- Результатом вызова ```typeof null``` является "object". Это официально признанная ошибка в typeof, ведущая начало с времён создания JavaScript и сохранённая для совместимости.
- Вызов ```typeof alert``` возвращает ```"function"```, потому что ```alert``` является функцией. Функции относятся к объектному типу. Но ```typeof``` обрабатывает их особым образом, возвращая ```"function"```. Так тоже повелось от создания JavaScript. Формально это неверно, но может быть удобным на практике.

<hr />
<hr />

<h3><b>Преобразование типов</b></h3>

Операторы и функции автоматически приводят переданные им значения к нужному типу. Иногда нам нужно явно преобразовать значение в ожидаемый тип. Далее будут различные виды преобразований.

1. Строковое преобразование происходит, когда требуется представление чего-либо в виде строки. Например, ```alert(value)``` преобразует значение к строке.
Можно использовать функцию ```String(value)```, чтобы преобразовать значение к строке:
```javascript
let value = true;
alert(typeof value); // boolean
value = String(value); // теперь value это строка "true"
alert(typeof value); // string
```
Преобразование происходит очевидным образом. ```false``` становится ```"false"```, ```null``` становится ```"null"``` и т.п.

2. Численное преобразование происходит в математических функциях и выражениях. Например, когда операция деления ```/``` применяется не к числу.
Можно использовать функцию ```Number(value)```, чтобы явно преобразовать ```value``` к числу:
```javascript
let str = "123";
alert(typeof str); // string
let num = Number(str); // становится числом 123
alert(typeof num); // number
```
Явное преобразование часто применяется, когда мы ожидаем получить число из строкового контекста. Если строка не может быть явно приведена к числу, то результатом преобразования будет ```NaN```. Например:
```javascript
let age = Number("Любая строка вместо числа");
alert(age); // NaN, преобразование не удалось
```
Также, есть некоторые правила преобразования примитивных типов:
- ```undefined -> NaN```;
- ```null -> 0```;
- ```true / false -> 1 / 0```;
- ```string``` преобразуется по правилу "Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат ```NaN```".

3. Логическое преобразование происходит в логических операциях, но также может быть выполнено явно с помощью ```Boolean(value)```.
Правило преобразования:
- Число ```0```, пустая строка ```""```, ```null```, ```undefined``` и ```NaN``` становятся ```false```. Из-за этого их называют «ложными» («falsy») значениями.
- Остальные значения становятся ```true```, поэтому их называют «правдивыми» («truthy»).
ВАЖНО!: Строчка с нулём "0" — это true. В JavaScript, если строка не пустая, то она всегда ```true```.
Примеры:
```javascript
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false
alert( Boolean("0") ); // true
alert( Boolean(" ") ); // пробел это тоже true (любая непустая строка это true)
alert( Boolean("Привет!") ); // true
alert( Boolean("") ); // false
```

<hr />
<hr />

<h3><b>Базовые операторы</b></h3>

Поддерживаются следующие математические операторы:

- Сложение ```+```.

а) Свойства бинарного (Бинарным называется оператор, который применяется к двум операндам) ```+```.
- Если бинарный оператор '+' применить к строкам, то он их объединяет в одну. Пример:
```javascript
let s = "моя" + "строка";
alert(s); // моястрока
```
ВАЖНО!: если хотя бы один операнд является строкой, то второй будет также преобразован в строку. Пример: 
```javascript
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```
ВАЖНО!: Сложение и преобразование строк — это особенность бинарного плюса +. Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа. Например, вычитание и деление:
```javascript
alert( 6 - '2' ); // 4, '2' приводится к числу
alert( '6' / '2' ); // 3, оба операнда приводятся к числам
```

б) Свойства унарного (Унарным называется оператор, который применяется к одному операнду (Операнд – то, к чему применяется оператор). Например, оператор унарный минус ```"-"``` меняет знак числа на противоположный) ```+```.
- Если операнд не число, унарный плюс преобразует его в число. Принцип такой же, как у ```Number(...)```. Пример: 
```javascript
// Не влияет на числа
let y = -2;
alert( +y ); // -2

// Преобразует не числа в числа
alert( +true ); // 1
alert( +"" );   // 0
```
Как это можно применить:
```javascript
let apples = "2";
let oranges = "3";
// оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5
// более длинный вариант
// alert( Number(apples) + Number(oranges) ); // 5
```

- Вычитание ```-```.
- Умножение ```*```.
- Деление ```/```.
- Взятие остатка от деления ```%```, где результат ```a % b``` – это остаток от целочисленного деления ```a``` на ```b```.
- Возведение в степень ```**```, где в выражении ```a ** b``` оператор возведения в степень умножает ```a``` на само себя ```b`` раз.

Приоритет выполнения операторов

Каждый оператор имеет соответствующий номер приоритета. Тот, у кого это число больше, – выполнится раньше. Если приоритет одинаковый, то порядок выполнения – слева направо.
В таблице можно проверить какой оператор выполниться первым: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
Важно знать, что унарные операторы имеют приоритет перед бинарными. Поэтому, сначала унарный плюс преобразует строку в число и потом только бинарный складывает числа.

Другие операторы

- Присваивание ```=```. У него один из самых низких приоритетов: 3. Именно поэтому, когда переменной что-либо присваивают, то сначала выполнится арифметика, а уже затем произойдёт присваивание с сохранением результата.

Особенность: Большинство операторов в JavaScript возвращают значение. Оператор присваивания не является исключением. Вызов ```x = value``` записывает ```value``` в ```x``` и возвращает его. Пример сложного выражения:
```javascript
let a = 1;
let b = 2;
let c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
```
Особенность: цепочка присваиваний. Пример: 
```javascript
let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```
Такое присваивание работает справа налево. Сначала вычисляется самое правое выражение 2 + 2, и затем результат присваивается переменным слева: c, b и a. В конце у всех переменных будет одно значение.

Нужно понимать как это работает. Но писать в таком стиле не рекомендуется. Такие трюки не сделают код более понятным или читабельным.

- Совмещённые операторы ```+=```, ```/=```, ```-=```, ```*=``` и тд. Пример:
```javascript
let n = 2;
n += 5; // теперь n = 7 (работает как n = n + 5)
n *= 2; // теперь n = 14 (работает как n = n * 2)
alert( n ); // 14
```
ВАЖНО!: Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после большинства других операций.

- Инкремент ```++```/ Декремент ```--```. Пример: 
```javascript
let counter = 2;
counter++;        // работает как counter = counter + 1, просто запись короче
alert( counter ); // 3
```
ВАЖНО!: Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа ```5++```, приведёт к ошибке.

Особенность: 

а) Когда оператор идёт после переменной — это «постфиксная форма»: ```counter++```.
```javascript
let counter = 1;
let a = ++counter; // (*)
alert(a); // 2
```
б) «Префиксная форма» — это когда оператор идёт перед переменной: ```++counter```.
```javascript
let counter = 1;
let a = counter++; // (*) меняем ++counter на counter++
alert(a); // 1
```
Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое (до увеличения/уменьшения числа). 

Особенность: Операторы ```++/--``` могут также использоваться внутри выражений. Их приоритет выше, чем у большинства других арифметических операций. Пример: 
```javascript
let counter = 1;
alert( 2 * ++counter ); // 4
```
или 
```javascript
let counter = 1;
alert( 2 * counter++ ); // 2, потому что counter++ возвращает "старое" значение
```
Но лучше использовать стиль «одна строка – одно действие».

- Побитовые операторы

Поддерживаются следующие побитовые операторы:
1) ```AND``` (и) - ```&```
2) ```OR``` (или) - ```|```
3) ```XOR``` (побитовое исключающее или) - ```^```
4) ```NOT``` (не) - ```~```
5) ```LEFT SHIFT``` (левый сдвиг) - ```<<```
6) ```RIGHT SHIFT``` (правый сдвиг) - ```>>```
7) ```ZERO-FILL RIGHT SHIFT``` (правый сдвиг с заполнением нулями) - ```>>>```

Подробнее, если понадобиться: https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators#%D0%91%D0%B8%D1%82%D0%BE%D0%B2%D1%8B%D0%B5_%D0%BF%D0%BE%D1%80%D0%B0%D0%B7%D1%80%D1%8F%D0%B4%D0%BD%D1%8B%D0%B5_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B

- Логические операторы

В JavaScript есть три логических оператора: ```||``` (ИЛИ), ```&&``` (И) и ```!``` (НЕ).

а) Оператор «ИЛИ». Синтаксис и возможные логические комбинации: 
```javascript
result = a || b;
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```
Если значение не логического типа, то оно к нему приводится. Обычно оператор ```||``` используется в ```if``` для проверки истинности любого из заданных условий. Пример: 
```javascript
let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( 'Офис закрыт.' ); // это выходной
}
```
ВАЖНО!: ИЛИ ```||``` находит первое истинное значение. При выполнении ```result = value1 || value2 || value3;``` АЛГОРИТМ: 
- Вычисляет операнды слева направо.
- Каждый операнд конвертирует в логическое значение. Если результат ```true```, останавливается и возвращает исходное значение этого операнда.
- Если все операнды являются ложными, возвращает последний из них.
Значение возвращается в исходном виде, без преобразования.
Например:
```javascript
alert( 1 || 0 ); // 1
alert( true || 'no matter what' ); // true
alert( null || 1 ); // 1 (первое истинное значение)
alert( null || 0 || 1 ); // 1 (первое истинное значение)
alert( undefined || null || 0 ); // 0 (поскольку все ложно, возвращается последнее значение)
```

Возможности "ИЛИ".
- Получение первого истинного значения из списка переменных или выражений. 
```javascript
let currentUser = null;
let defaultUser = "John";
let name = currentUser || defaultUser || "unnamed";

alert( name ); // выбирается "John" – первое истинное значение
```
Если бы и ```currentUser```, и ```defaultUser``` были ложными, в качестве результата мы бы наблюдали ```"unnamed"```.
- Сокращённое вычисление.
```javascript
let x;
true || (x = 1);

alert(x); // undefined, потому что (x = 1) не вычисляется
```
Если бы первый аргумент имел значение ```false```, то ```||``` приступил бы к вычислению второго и выполнил операцию присваивания.

б) Оператор "И". Синтаксис и возможные логические комбинации:
```javascript
result = a && b;
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```  
Пример использования. Проверка времени:
```javascript
let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'The time is 12:30' );
}
```
ВАЖНО!: И ```&&``` находит первое ложное значение. При выполнении ```result = value1 && value2 && value3;``` АЛГОРИТМ:
- Вычисляет операнды слева направо.
- Каждый операнд преобразует в логическое значение. Если результат ```false```, останавливается и возвращает исходное значение этого операнда.
- Если все операнды были истинными, возвращается последний.
Пример: 
```javascript
// Если первый операнд истинный,
// И возвращает второй:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5
// Если первый операнд ложный,
// И возвращает его. Второй операнд игнорируется
alert( null && 5 ); // null
alert( 0 && "no matter what" ); // 0
```
ВАЖНО!: Приоритет оператора ```&&``` больше, чем у ```||```. Код ```a && b || c && d``` по существу такой же, как если бы выражения ```&&``` были в круглых скобках: ```(a && b) || (c && d)```.

в) Оператор НЕ. Синтаксис и возможные логические комбинации:
```javascript
result = !value; // Сначала аргумент приводится к логическому типу true/false. Затем возвращает противоположное значение.
alert( !true ); // false
alert( !0 ); // true
```
Двойное НЕ используют для преобразования значений к логическому типу:
```javascript
alert( !!"non-empty string" ); // true первое НЕ преобразует значение в логическое значение и возвращает обратное, второе НЕ снова инвертирует его.
alert( !!null ); // false
// Другой способ сделать то же самое – встроенная функция Boolean
alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
```
ВАЖНО!: Приоритет НЕ ```!``` является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед ```&&``` или ```||```.

- Оператор «запятая» ```,```

Оператор «запятая» предоставляет нам возможность вычислять несколько выражений, разделяя их запятой ```,```. Каждое выражение выполняется, но возвращается результат только последнего.
```javascript
let a = (1 + 2, 3 + 4);
alert( a ); // 7 (результат вычисления 3 + 4)
```
ВАЖНО!: оператор ```,``` имеет очень низкий приоритет, ниже ```=```, поэтому скобки важны в приведённом выше примере. Без них в ```a = 1 + 2, 3 + 4``` сначала выполнится ```+```, суммируя числа в ```a = 3, 7```, затем оператор присваивания ```=``` присвоит ```a = 3```, а то, что идёт дальше, будет игнорировано. Всё так же, как в ```(a = 1 + 2), 3 + 4```.

Пример использования. Иногда его используют в составе более сложных конструкций, чтобы сделать несколько действий в одной строке.
```javascript
// три операции в одной строке
for (a = 1, b = 3, c = a * b; a < 10; a++) {
 ...
}
```

- Операторы сравнения

Виды:

- Больше/меньше: ```a > b```, ```a < b```.
- Больше/меньше или равно: ```a >= b```, ```a <= b```.
- Равно: ```a == b```. 
- Не равно: ```a != b```.

Все они возращают булевое значение ```true``` или ```false```.
Результат можно присвоить переменной:
```javascript
let result = 5 > 4; // результат сравнения присваивается переменной result
alert( result ); // true
```

Сравнения: 

- Строки
    Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок т.е. строки сравниваются посимвольно.
    Например:
```javascript
alert( 'Я' > 'А' ); // true
alert( 'Коты' > 'Кода' ); // true
alert( 'Сонный' > 'Сон' ); // true
```
Описание: В примерах сравнение 'Я' > 'А' завершится на первом шаге. Строки 'Коты' и 'Кода' будут сравниваться посимвольно: К равна К. о равна о. т больше, чем д. На этом сравнение заканчивается. Первая строка больше.

Алгоритм сравнения двух строк довольно прост:

- Сначала сравниваются первые символы строк.
- Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй. Сравнение завершено.
- Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.
- Сравнение продолжается, пока не закончится одна из строк.
- Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.

ВАЖНО!: Заглавная буква "A" не равна строчной "a". Какая же из них больше? Строчная "a". Строчные буквы имеют больший код во внутренней таблице кодирования Unicode.

- Разные типы

    При сравнении значений разных типов JavaScript приводит каждое из них к числу. Логическое значение true становится 1, а false – 0. Пример:
```javascript
alert( '2' > 1 ); // true, строка '2' становится числом 2
alert( '01' == 1 ); // true, строка '01' становится числом 1
```

- Строгое равенство (```===```)

    Оператор строгого равенства ```===``` проверяет равенство без приведения типов. Пример:
```javascript
alert( 0 === false ); // false, так как сравниваются разные типы, хотя при обычном сравнении было бы true
```
Строгое равество позволяет избегать ошибок.

- Особенности типов ```null``` и ```undefined```
    Сравнение между собой.
    При СТРОГОМ равенстве ```===``` эти значения различны, так как различны их типы.
    При НЕСТРОГОМ равенстве ```==``` эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.

Сравнение с другими значениями.

При использовании математических операторов и других операторов сравнения ```<, >, <=, >=``` значения ```null/undefined``` преобразуются к числам: ```null``` становится ```0```, а ```undefined – NaN```.
Примеры:

- Сравнение ```null``` с нулём:
```javascript
alert( null > 0 );  // (1) false Сравнения преобразуют null в число, рассматривая его как 0. Поэтому выражение null >= 0 истинно, а null > 0 ложно.
alert( null == 0 ); // (2) false для нестрогого равенства == значений undefined и null действует особое правило: эти значения ни к чему не приводятся. Поэтому null == 0 ложно.
alert( null >= 0 ); // (3) true
```

- Сравнение ```undefined``` с нулём:
```javascript
alert( undefined > 0 ); // false (1) Сравнения возвращают false, потому что undefined преобразуется в NaN – это специальное числовое значение, которое возвращает false при любых сравнениях.
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3) Нестрогое равенство возвращает false, потому что undefined равно только null, undefined и ничему больше.
```

<hr />
<hr />

<h3><b>Условные ветвления</b></h3>

Инструкция ```if``` и блок ```else```.

Инструкция ```if(...)``` вычисляет условие в скобках и, если результат true, то выполняет блок кода. Например:
```javascript
let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');
if (year == 2015) {
  alert( "Правильно!" );
  alert( "Вы такой умный!" );
}
```
Если инструкция одна, то можно убрать фигурные скобки, но лучше использовать их всегда.

Инструкция ```if``` может содержать необязательный блок ```else``` («иначе»). Он выполняется, когда условие ложно. Также, когда нужно проверить несколько вариантов условия используется блок ```else if```. Пример:
```javascript
let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

if (year < 2015) {
  alert( 'Это слишком рано...' );
} else if (year > 2015) {
  alert( 'Это поздновато' );
} else {
  alert( 'Верно!' );
}
```

Условный оператор ```?```

Оператор представлен знаком вопроса ```?```. Его также называют «тернарный». Он имеет три аргумента. Синтаксис:
```javascript
let result = условие ? значение1 : значение2;
```
Алгоритм: сначала вычисляется условие и если оно истинно, тогда возвращается значение1, в противном случае – значение2. Пример: 
```javascript
let accessAllowed = (age > 18) ? true : false;
```
При использовании ```if``` это выглядит более громоздко:
```javascript
let accessAllowed;
let age = prompt('Сколько вам лет?', '');

if (age > 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}
alert(accessAllowed);
```
Можно испльзовать несколько операторов ```?```
```javascript
let age = prompt('Возраст?', 18);

let message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';
alert( message );
```
Тоже самое в ```if```: 
```javascript
if (age < 3) {
  message = 'Здравствуй, малыш!';
} else if (age < 18) {
  message = 'Привет!';
} else if (age < 100) {
  message = 'Здравствуйте!';
} else {
  message = 'Какой необычный возраст!';
}
```

- Оператор объединения с null ```??```

Оператор ```??``` возвращает первый аргумент, если он не ```null/undefined```, иначе второй.
Результат выражения ```a ?? b``` будет следующим:
1) ```a```, если значение ```a``` определено,
2) ```b```, если значение ```a``` не определено.

```result = a ?? b``` упрощенная запись ```result = (a !== null && a !== undefined) ? a : b;```.

В основном оператор ```??``` нужен для того, чтобы задать значение по умолчанию для потенциально неопределённой переменной. Пример: 
```javascript
let user;
alert(user ?? "Аноним"); // Аноним
```
```javascript
let user = "Иван";
alert(user ?? "Аноним"); // Иван
```
Можно заменить ```??``` на ```||```, то будет тот же самый результат.
```javascript
let user = "Иван";
alert(user || "Аноним"); // Иван
```
Раньше, так и было, сейчас есть спец. оператор ```??``` для этого. ВАЖНОЕ отличие этих двух операторов:
а) ```||``` возвращает первое истинное значение.
б) ```??``` возвращает первое определённое значение.

Оператор ```??``` имеет низкий приоритет. Если нужно выбрать значение при помощи оператора ```??``` вместе с другими операторами в выражении, следует добавить круглые скобки. Иначе, если опустить скобки, то другой оператор выполнится первым.
```javascript
// без круглых скобок
let area = height ?? 100 * width ?? 50;
// ...то же самое, что предыдущее выражение (вероятно, это не то, что нам нужно):
let area = height ?? (100 * width) ?? 50;
```

По соображениям безопасности JavaScript запрещает использование оператора ```??``` вместе с ```&&``` и ```||```. Обойти это можно, используя круглые скобки:
```javascript
let x = 1 && 2 ?? 3; // Синтаксическая ошибка
let y = (1 && 2) ?? 3; // Работает без ошибок
alert(y); // 2
```

<hr />
<hr />

<h3><b>Циклы while и for</b></h3>

Для многократного повторения одного участка кода предусмотрены циклы. Циклы:
1) Цикл while имеет следующий синтаксис:
```javascript
while (condition) {
  // код
  // также называемый "телом цикла"
}
```
Любое выражение или переменная может быть условием цикла: условие while вычисляется и преобразуется в логическое значение. Например, while (i) – более краткий вариант while (i != 0):
```javascript
let i = 3;
while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
  alert( i );
  i--;
}
```

2) Цикл «do…while» сначала выполнит тело, а затем проверит условие condition:
```javascript
do {
  // тело цикла
} while (condition);
```
Такой цикл можно использовать, чтобы тело цикла выполнилось хотя бы один раз. 

3) Цикл «for» имеет следующий синтаксис:
```javascript
for (начало; условие; шаг) {
  // ... тело цикла ...
}
```
Инструкции для цикла:

- начало:	i = 0	ВАЖНО!: Выполняется один раз при входе в цикл;
- условие:	i < 3	Проверяется перед каждой итерацией цикла. Если оно вычислится в false, цикл остановится;
- шаг:	i++	Выполняется после тела цикла на каждой итерации перед проверкой условия;
- тело:	alert(i)	Выполняется снова и снова, пока условие вычисляется в true.

Особенность: в счетчике можно использовать, как ранее заданную переменную, так и задать переменную прямо в цикле. Но тогда переменная не будет видна снаружи.

Любая часть for может быть пропущена. Мы можем пропустить начало, шаг или всё. Примеры: 
```javascript
// начало
let i = 0; // мы уже имеем объявленную i с присвоенным значением
for (; i < 3; i++) { // нет необходимости в "начале"
  alert( i ); // 0, 1, 2
}
// шаг, это сделает цикл аналогичным while (i < 3).
let i = 0;

for (; i < 3;) {
  alert( i++ );
}
// всё
for (;;) {
  // будет выполняться вечно
}
```

Прерывание цикла: «break» и переход к следующей итерации: continue

Мы можем выйти из цикла в любой момент с помощью break. Пример: 
```javascript
let sum = 0;
while (true) {
  let value = +prompt("Введите число", '');
  if (!value) break; // Цикл прерывается, если пользователь перестал вводить числа.
  sum += value;
}
alert( 'Сумма: ' + sum );
```
Сочетание «бесконечный цикл + break» – отличная штука для тех ситуаций, когда условие, по которому нужно прерваться, находится посередине.

Директива continue – при выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true). Например, цикл ниже использует continue, чтобы выводить только нечётные значения:
```javascript
for (let i = 0; i < 10; i++) {
  // если true, пропустить оставшуюся часть тела цикла
  if (i % 2 == 0) continue;
  alert(i); // 1, затем 3, 5, 7, 9
}
```

ВАЖНО!: В частности, использование таких директив, как break/continue, вызовет ошибку при использовании с тернарным оператором ?, потому что они не являются выражениями. Пример:
```javascript
(i > 5) ? alert(i) : continue; // continue здесь приведёт к ошибке
```

Метки для break/continue

Вызов break <labelName> в цикле ниже ищет ближайший внешний цикл с такой меткой и переходит в его конец. Это нужно, чтобы выйти одновременно из нескольких уровней цикла сразу. Пример: 
```javascript
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let input = prompt(`Значение на координатах (${i},${j})`, '');
    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) break outer; // (*)
    // сделать что-нибудь со значениями...
  }
}
alert('Готово!');
```
Вызов break outer будет разорван внешний цикл до метки с именем outer, и управление перейдёт со строки, помеченной (*), к alert('Готово!'). Директива continue также может быть использована с меткой. В этом случае управление перейдёт на следующую итерацию цикла с меткой.

ВАЖНО!: Метки не дают возможности передавать управление в произвольное место кода. Вызов break/continue возможен только внутри цикла, и метка должна находиться где-то выше этой директивы. Пример:
```javascript
break label; // не прыгает к метке ниже
label: for (...)
```

<hr />
<hr />

<h3><b>Конструкция "switch"</b></h3>

Конструкция "switch" имеет один или более блок case и необязательный блок default. Синтаксис:
```javascript
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]
  case 'value2':  // if (x === 'value2')
    ...
    [break]
  default:
    ...
    [break]
}
``` 
ВАЖНО!: Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются.

Несколько вариантов case, использующих один код, можно группировать. Пример: 
```javascript
let a = 2 + 2;

switch (a) {
  case 4:
    alert('Правильно!');
    break;
  case 3: // (*) группируем оба case, теперь оба варианта 3 и 5 выводят одно сообщение.
  case 5:
    alert('Неправильно!');
    alert("Может вам посетить урок математики?");
    break;
  default:
    alert('Результат выглядит странновато. Честно.');
}
``` 
ВАЖНО!: проверка на равенство всегда строгая. Значения должны быть одного типа, чтобы выполнялось равенство в кейсах.

<hr />
<hr />

<h3><b>Функции</b></h3>

Функции - нужны, чтобы не повторять один и тот же код во многих местах

Объявление функции:
```javascript
function имя(параметры) {
  ...тело...
}

//или

let sayHi = function() {
  alert( "Привет" );
};
```
Вызов осуществляется с помощью написания имени функции и круглых скобок после него. Пример:
```javascript
function showMessage() {
  alert( 'Всем привет!' );
}
showMessage();
showMessage();
```
Особеноость: переменные, объявленные внутри функции, видны только внутри этой функции. А также, функция обладает полным доступом к внешним переменным и может изменять их значение. Но внешняя переменная используется, только если внутри функции нет такой локальной. Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю.

Для передачи данных внутрь функции мы можем использовать аргументы функции. Примеры:
```javascript
function showMessage(from, text) { // аргументы: from, text
  alert(from + ': ' + text);
}

showMessage('Аня', 'Привет!'); // Аня: Привет! (*)
showMessage('Аня', "Как дела?"); // Аня: Как дела? (**)

//или

function showMessage(from, text) {
  from = '*' + from + '*'; // немного украсим "from"
  alert( from + ': ' + text );
}

let from = "Аня";
showMessage(from, "Привет"); // *Аня*: Привет
// значение "from" осталось прежним, функция изменила значение локальной переменной
alert( from ); // Аня
```

ВАЖНО!: Если параметр не указан, то его значением становится ```undefined```. То есть: 
```javascript
function showMessage(from, text) {
  alert( from + ": " + text );
}

showMessage("Аня"); // Аня: undefined
```

Чтобы этого избежать можно установить значение по умолчанию. Если мы хотим задать параметру значение по умолчанию, мы должны указать его после ```=```. Это может быть строка или другая функция. Пример: 
```javascript
function showMessage(from, text = "текст не добавлен") {
  alert( from + ": " + text );
}

showMessage("Аня"); // Аня: текст не добавлен
```

Функция может вернуть результат, который будет передан в вызвавший её код. Директива return может находиться в любом месте тела функции. Как только выполнение доходит до этого места, функция останавливается, и значение возвращается в вызвавший её код.
Возможно использовать return и без значения. Это приведёт к немедленному выходу из функции. Примеры:
```javascript
function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert( result ); // 3

// или

function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm('А родители разрешили?');
  }
}

let age = prompt('Сколько вам лет?', 18);
if ( checkAge(age) ) {
  alert( 'Доступ получен' );
} else {
  alert( 'Доступ закрыт' );
}

// или

function showMovie(age) {
  if ( !checkAge(age) ) {
    return;
  }
  alert( "Вам показывается кино" ); // (*)
  // ...
}
```

Особенность: Результат функции с пустым return или без него – undefined. Примеры:
```javascript
function doNothing() { /* пусто */ }

alert( doNothing() === undefined ); // true

// или

function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true
```

ВАЖНО!: Нельзя ставить перевод строки между return и его значением.

Именование функци и хорошие практики

- Как правило, используются глагольные префиксы, обозначающие общий характер действия, после которых следует уточнение. Примеры:
```
showMessage(..)     // показывает сообщение
getAge(..)          // возвращает возраст (в каком либо значении)
calcSum(..)         // вычисляет сумму и возвращает результат
createForm(..)      // создаёт форму (и обычно возвращает её)
checkPermission(..) // проверяет доступ, возвращая true/false
```
- Одна функция – одно действие. Функция должна делать только то, что явно подразумевается её названием. И это должно быть одним действием.

Функция - это значение. Можно скопировать функцию в другую переменную. Пример: 
```javascript
function sayHi() {   // (1) создаём
  alert( "Привет" );
}
let func = sayHi;    // (2) копируем
func(); // Привет    // (3) вызываем копию (работает)!
sayHi(); // Привет   //     прежняя тоже работает (почему бы нет)
```

Функция callback

Ключевая идея в том, что мы передаём функцию и ожидаем, что она вызовется обратно (от англ. «call back» – обратный вызов) когда-нибудь позже, если это будет необходимо. Пример:
```javascript
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
function showOk() {
  alert( "Вы согласны." );
}
function showCancel() {
  alert( "Вы отменили выполнение." );
}
// использование: функции showOk, showCancel передаются в качестве аргументов ask
ask("Вы согласны?", showOk, showCancel);
```
Аргументы функции ask ещё называют функциями-колбэками или просто колбэками.

Или можно переписать этот пример, используя Function Expression:
```javascript
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);
```
Без имён функции называются анонимными. Такие функции недоступны снаружи.

Ключевые отличия Function Declaration от Function Expression.

1. Синтаксис.

Function Declaration: функция объявляется отдельной конструкцией «function…» в основном потоке кода.
```javascript
// Function Declaration
function sum(a, b) {
  return a + b;
}
```
Function Expression: функция, созданная внутри другого выражения или синтаксической конструкции. В данном случае функция создаётся в правой части «выражения присваивания» =:
```javascript
// Function Expression
let sum = function(a, b) {
  return a + b;
};
```

2. Создание функции движком JavaScript.

Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.

Function Declaration можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке). Другими словами, движок JavaScript готовится выполнять скрипт или блок кода, прежде всего он ищет в нём Function Declaration и создаёт все такие функции. Можно считать этот процесс «стадией инициализации». И только после того, как все объявления Function Declaration будут обработаны, продолжится выполнение. В результате, функции, созданные, как Function Declaration могут быть вызваны раньше своих определений.

Стрелочные функции

Синтаксис:
```javascript
let func = (arg1, arg2, ...argN) => expression
```
Код создаёт функцию func с аргументами arg1..argN и вычисляет expression с правой стороны с их использованием, возвращая результат. Другими словами, это более короткий вариант такой записи:
```javascript
let func = function(arg1, arg2, ...argN) {
  return expression;
};
```
Если нужно выполнить несколько действий, то нужны фигурные скобки и использовать return внутри них, как в обычной функции:
```javascript
let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
  let result = a + b;
  return result; // при фигурных скобках для возврата значения нужно явно вызвать return
};
alert( sum(1, 2) ); // 3
```
Конкретный пример: 
```javascript
let sum = (a, b) => a + b;
/* Более короткая форма для:
let sum = function(a, b) {
  return a + b;
};
*/
alert( sum(1, 2) ); // 3
```
Функции-стрелки могут быть использованы так же, как и Function Expression в условных ветвлениях или циклах, чтобы была внешняя видимость. Например, для динамического создания функции:
```javascript
let age = prompt("Сколько Вам лет?", 18);
let welcome = (age < 18) ?
  () => alert('Привет') :
  () => alert("Здравствуйте!");
welcome(); // теперь всё в порядке
```
<hr />
<hr />